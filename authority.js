// Generated by CoffeeScript 1.8.0
(function() {
  var Authority, createHash, execFile, isBuffer;

  execFile = require("child_process").execFile;

  createHash = require("crypto").createHash;

  isBuffer = Buffer.isBuffer;

  module.exports = Authority = (function() {
    function Authority(options) {
      if (options == null) {
        options = {};
      }
      this.key = options.key, this.certificate = options.certificate;
    }

    Authority.prototype.certify = function(input, callback) {
      var param, params, _i, _len, _ref;
      if (input == null) {
        input = {};
      }
      params = {
        "signing_certificate": this.certificate,
        "signing_key": this.key
      };
      _ref = this.certifyParams;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        param = _ref[_i];
        params[param] = input[param];
      }
      return Authority.createCertificate(params, callback);
    };

    Authority.prototype.certifyParams = ["subject", "subject_key", "subject_public_key", "subject_signed_public_key", "started_at", "expires_at", "serial_number", "extensions"];

    Authority.createCertificate = function(params, callback) {
      var param, _i, _len, _ref;
      if (callback == null) {
        callback = params.callback || function() {};
      }
      _ref = ["signing_key", "signing_certificate", "subject_key"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        param = _ref[_i];
        if (isBuffer(params[param])) {
          params[param] = params[param].toString("utf-8");
        }
      }
      if (params["subject_signed_public_key"] != null) {
        params["subject_signed_public_key"] = params["subject_signed_public_key"].replace("\r\n", "").trim();
      }
      params["subject"] = Authority.convertSubjectToDistinguishedName(params["subject"]);
      if (params["extensions"] == null) {
        params["extensions"] = [];
      }
      params["extensions"].push(Authority.makeBasicConstraintsFor(params));
      params["extensions"].push({
        name: "subjectKeyIdentifier",
        value: "hash",
        critical: false
      });
      params["extensions"].push({
        name: "authorityKeyIdentifier",
        value: "keyid:issuer",
        critical: false
      });
      if (params["serial_number"] == null) {
        params["serial_number"] = Authority.makeSerialNumberFor(params);
      }
      return Authority.execRuby("certify", params, function(error, output) {
        if (error) {
          return callback(new Error(error.toString().split("\n")[0].split("<main>':")[1].trim()));
        } else {
          return callback(void 0, {
            text: output["text"],
            fingerprint: output["fingerprint"],
            serialNumber: params["serial_number"],
            der: new Buffer(output["base64_encoded_der"], "base64"),
            pem: new Buffer(output["pem"], "UTF-8")
          });
        }
      });
    };

    Authority.convertSubjectToDistinguishedName = function(subject) {
      var converted, key, value;
      converted = {};
      for (key in subject) {
        value = subject[key];
        converted[this.DISTINGUISHED_NAME_FIELDS[key]] = value;
      }
      return converted;
    };

    Authority.DISTINGUISHED_NAME_FIELDS = {
      "common_name": "CN",
      "title": "title",
      "organization": "O",
      "organizational_unit": "OU",
      "business_category": "businessCategory",
      "email_address": "emailAddress",
      "street_address": "STREET",
      "location": "L",
      "region": "ST",
      "country_code": "C",
      "user_id": "UID"
    };

    Authority.makeSerialNumberFor = function(params) {
      var hash;
      hash = createHash("SHA1");
      hash.update(JSON.stringify(params["subject"]));
      hash.update((new Date).toJSON());
      if (params["subject_signed_public_key"] != null) {
        hash.update(params["subject_signed_public_key"]);
      }
      return hash.digest("hex");
    };

    Authority.makeBasicConstraintsFor = function(params) {
      var extension;
      extension = {
        name: "basicConstraints",
        critical: true
      };
      extension.value = (function() {
        var _ref;
        switch (false) {
          case ((_ref = params["certificate_authority"]) != null ? _ref.pathlen : void 0) == null:
            return "CA:TRUE,pathlen:" + params["certificate_authority"].pathlen;
          case params["certificate_authority"] !== true:
            return "CA:TRUE";
          default:
            return "CA:FALSE";
        }
      })();
      return extension;
    };

    Authority.execRuby = function(script, params, callback) {
      return this.locateRuby((function(_this) {
        return function(error, ruby) {
          if (error != null) {
            return callback(error);
          }
          return execFile(ruby, ["" + __dirname + "/" + script + ".rb", JSON.stringify(params)], function(error, stdout) {
            var output;
            if (error == null) {
              output = JSON.parse(stdout);
            }
            return callback(error, output);
          });
        };
      })(this));
    };

    Authority.locateRuby = function(callback) {
      if (this.ruby != null) {
        return callback(void 0, this.ruby);
      } else {
        return execFile("/usr/bin/which", ["ruby"], (function(_this) {
          return function(error, stdout) {
            if ((error != null ? error.code : void 0) === 1) {
              error(new Error('Canâ€™t locate your copy of ruby. Please set Authority.ruby = "path/to/your/ruby"'));
            } else {
              _this.ruby = stdout.trim();
            }
            return callback(error, _this.ruby);
          };
        })(this));
      }
    };

    return Authority;

  })();

}).call(this);
